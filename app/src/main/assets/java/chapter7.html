<!DOCTYPE html>
<html>
<head>
    <title>第八章 继承 - 邠心工作室</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no" />
    <link href="css/main.css" rel="stylesheet" />
    <script src="Script/shCore.js" type="text/javascript"></script>
    <script src="Script/shBrushJava.js" type="text/javascript"></script>
    <link href="css/shCoreDefault.css" rel="stylesheet" type="text/css" />
    <script type="text/javascript">
        SyntaxHighlighter.all();
    </script>
</head>
<body>
    <div class="div">
        <blockquote>
            经过了前面学习，对面向对象有了一定的认识，下面开始学习面向对象的一个重要的概念——继承。在此基础上讨论重写、重载、重写与重载之间的区别，以及多态和如何灵活运用final、abstract等概念，因此学好这些概念是灵活运用多态的基石。通过本章的学习，同学们应该能够完成如下几个目标。
            <ol>
                <li>了解什么是继承和继承如何使用。</li>
                <li>掌握声明成员变量的修饰符。</li>
                <li>熟练掌握方法的重写和重载。</li>
                <li>了解枚举、反射和泛型等热门技术。</li>
            </ol>
        </blockquote>
        <h3>8.1  什么是继承</h3>
        <p>在日常生活中，经常遇到如下问题。有一辆自行车，自行车有颜色和型号大小之分，而公路赛车也有颜色和型号大小之分，公路赛车多了一项速度的优势。自行车有的东西公路赛车全都有，而公路赛车有的东西自行车不一定有，它们相同地方有很多。在Java中，对于这种情况下就采用继承来完成这个功能。</p>
        <pre class="brush:java">//这是一个类，表述的是一个自行车  
public class bike
{
	public String color; 	//自行车的颜色 
    public int size; 		//自行车的大小,即型号
}
	
//这是一个类，表述的是一个公路赛类
pubic class racing_cycle
{
	public String color;  	//自行车的颜色
    public int size;      	//自行车的大小,即型号
    public String speed; 	//公路赛车的速度
}</pre>
        <p>下面就来使用继承来简化上面的程序。 </p>
        <pre class="brush:java">//这是一个类，表述的是一个自行车
public class bike
{
	public String color;	//自行车的颜色
    public int size; 			//自行车的大小，即型号
}
//这是一个类，表述的是一个公路赛车，它继承于自行车
pubic class racing_cycle extends bike
{
    public String speed;  		//公路赛车的速度
}</pre>
        <p>继承是为了让代码重复使用，提高效率，在此基础上衍生出更多的新类。继承是面向对象编程的特点，没有继承就不是面向对象编程，而是面向过程了。Java提供了单一继承，通过接口可以实现多重继承。本节要说明什么是继承，继承有哪些特点。</p>
        <h4>8.1.1  类的继承</h4>
        <p>在Java中，被继承的类叫超类（superclass），继承超类的类叫子类（subclass）。因此，子类是超类的一个功能上的扩展，它继承了超类定义的所有属性和方法，并且添加了特有功能方法。</p>
        <p>首先举一个典型例子来说明继承有什么特点，然后再结合代码学习。</p>
        <p class="exap">有一对爷俩，爸爸和儿子，爸爸的眼睛是单眼皮，个子很高，头发很好，皮肤很黑，而儿子同样有他爸爸的一些特征，但是儿子的皮肤很白，双眼皮，戴眼镜，在外人看来他们是爷俩。儿子具有爸爸的所有特征，但是儿子的皮肤很白和戴眼睛这些是儿子自己所特有的，也是和爸爸不一样的地方。这个小例子正是日常生活里常见的。</p>
        <p>换到Java里，类与类之间的关系，可以看成倒置的金字塔，爸爸在上面，儿子在下面。爸爸可能有多个儿子，但是一个儿子只能有一个爸爸，这在日常生活里也是如此。</p>
        <hr />
        <p>本节学习了继承的使用，下面对其内容做如下总结。</p>
        <ul>
            <li>通过继承定义类，可以简化类的定义，让所需要的功能用相应的子类去定义和实现。</li>
            <li>Java是单继承的，子类可以有很多，父类只能有一个。上面的例子，如果加一个Friend类，Son只能继承自Father，要么继承Friend，不能同时继承Father和Friend。</li>
            <li>Java的继承是多层继承的，是一个类可以有很多子类，而子类下面又可以有很多子类。</li>
            <li>父类里的属性和方法可以让子类所有，父类里的属性和方法可以使子类同样拥有，而子类的不能调用父类的方法和属性，子类的无参构造器默认是调用的父类的无参构造器。</li>
            <li>父类没有定义一个无参的构造器，那么编译器就默认生成一个无参的构造器，也可以在子类构造器里显示使用super方法调用父类构造器，super方法里写几个参数就可以表示调用的是父类的哪一个构造器。</li>
            <li>一般情况下，定义了一个有参的构造器，就应该定义一个无参的构造器。</li>
        </ul>
        <h4>8.1.2  继承的语法</h4>
        <p>
            类的继承是通过Java保留的关键字extends来修饰的，通过extends的关键字表明前者具备后者的公共的成员变量和方法，在具备了所有的公共的成员变量和方法后，本身还能定义一些特有的成员变量和方法。基本语法如下所示。<br />
            <b>class 类名 extends 父类名称</b>
        </p>
        <pre class="brush:java">public class Father
{
	public String name; 		//父亲的名字
	public int age; 			//父亲的年龄
	public String eye; 			//父亲眼睛的样子
	public String height; 		//父亲的身高
	public String cutis; 		//父亲的皮肤的颜色
}
public class Son extends Father 	//Son类继承与Father类
{
	public String spectacle_frame;  //这个属性是儿子所特有的 表示儿子是否带眼镜
} 
</pre>
        <h3>8.2  修饰符</h3>
        <p>修饰符是修饰的当前成员变量的访问限制和状态的。就好比一个眼镜，颜色是黑色的，这个黑色就修饰了这个眼镜，而眼镜的种类很多可以让不同的人群来使用，如近视眼镜就由有近视眼的人群来使用，别人来使用的话就不好了。</p>
        <pre class="brush:java">public String name;	//public 就是一个修饰符</pre>
        <p>成员变量的继承是指B继承与A后，B能使用A的属性和方法，是受成员变量的修饰符决定的。在上一节的例子里的成员变量都是使用的默认修饰符，本小节将详细介绍修饰符是如何限制成员变量的继承的。主要有4个修饰符：public、private、default、protected，对其详细介绍将分为小节来进行。</p>
        <h4>8.2.1 public：声明成员变量为公共类型</h4>
        <p>public表明被它修饰的成员变量为公共类型，那么这个成员变量在任何包里都能访问，包括子类也能访问到。</p>
        <h4>8.2.2 private：声明成员变量为私有类型</h4>
        <p>private表明被它修饰的成员变量为私有类型，表示除了本类外任何类都不能访问到这个成员变量，具有很好的保护性。</p>
        <h4>8.2.3 default：声明成员变量为默认类型</h4>
        <p>如果不给成员变量添加任何修饰符，就表示这个成员变量被修饰为default类型，在一个同包里的类或子类是能够访问的，相当于public类型，但是在不同包里的类或子类没有继承该成员变量，是访问不到它的。</p>
        <h4>8.2.4 protected：声明成员变量为保护类型</h4>
        <p>protected表明被它修饰的成员变量为保护类型，在同一包里和public类型是一样的，也是能够访问到的，但是如果在不同包里的protected类型的成员变量就只能通过子类来访问，这个修饰符是区别于其他的修饰符的。</p>
        <pre class="brush:java">public class Example
{
    public int a; //公共类型变量
    private int b; //私有类型变量
    protected int c; //受保护的变量
    int d; //默认类型的变量，同private
}</pre>
        <h3>8.3  成员变量的覆盖</h3>
        <p>正如前面所举爸爸和儿子的例子，爸爸的眼睛是单眼皮，儿子的是双眼皮，不能说儿子没有继承爸爸的特性，只能说明儿子的特性把爸爸的覆盖了。成员变量的覆盖是子类里有和父类里相同的成员变量或方法，继承的关系，子类的成员变量将会使用，而父类的成员变量被保护起来,有时也因修饰符原因而变化。</p>
        <h3>8.4  对象引用</h3>
        <p>对象引用就好比一个人的名字，是一个代号。也是为了方便和容易记忆所用的。比如去商店里买水果，进门就说我要买水果，而售货员也不知道要买的是什么。在Java里定义了一个类，这个类里有很多的成员变量和方法，再给这个类起一个名字，这个名字就是这个对象的引用。</p>
        <pre class="brush:java">bike b = new bike();</pre>
        <p class="exap">
            代码说明:<br />
            bike b是创建bike类的一个对象引用，而这个b就相当于bike的名字。<br />
            new bike()相当于把bike这个类实例化了，真实存在于内存当中了。
        </p>
        <h3>8.5  方法的重写和重载</h3>
        <p>方法的重写和重载是体现继承特性的重要方面，理解了方法的重写和重载，可以为以后学习多态打下基础，本节重点学习重写和重载的用法和区别。</p>
        <h4>8.5.1  方法重写的特点</h4>
        <p>自行车的移动和公路赛车的移动都是靠外力来移动，二者是相同的。公路赛车继承了这一特点，但公路赛车的移动速度就不相同了，移动的快慢就是由它们各自移动特性不相同决定的，方法继承的特点和成员变量的覆盖很类似，但也有特殊情况，方法重写也可以叫方法的覆盖。关键字为override。</p>
        <p class="exap">【范例】下面用例子说明在日常生活中自行车和公路赛车的相同点和不同点。</p>
        <pre class="brush:java">//这是一个类，表述的是一个自行车
public class bike
{
    public String color; //自行车的颜色
    public int size; //自行车的大小，即型号
    public void run()
    {
        System.out.println("自行车骑行");
    }
}
//这是一个类，表述的是一个公路赛车，它继承于自行车
pubic class racing_cycle extends bike
{
    public String speed;  //公路赛车的速度
    
    @Override
    public void run()   //方法重写
    {
        System.out.println("公路赛车骑行");
    }
}</pre>
        <h4>8.5.2  方法重载的特点</h4>
        <p>方法的重载就好比日常生活中人的名字，有大名也有小名，但这些名字都指的是这个人，不同点就是让这个人去做的事情可能不一样，如图所示。</p>
        <img src="http://vbe.tutc.cc:8081/xml/image/201805171317.jpg" />
        <p>这和Java里的重载很相似，关键字为overload。下面看一下重载的要求。</p>
        <p>重载的方法名称相同，但方法的参数列表不相同。如参数个数和参数类型等。<br />重载的方法的返回值可以相同也可以不相同。</p>
        <pre class="brush:java">public String move(){};
public String move(String name){};
public void move(String name, int spend){};
</pre>
        <p class="exap">代码说明：<br />虽然三种方法的名称是相同的，但这三种方法的的参数列表，即个数和类型，是不相同的。</p>
        <p>判断方法是否是重载，看参数列表是很重要的。<br />什么是传递基本类型，所谓基本类型就是用于数学计算的那些类型。当有两个名称一样的方法时，根据传递数值的类型来匹配哪两个方法的参数列表是相同的。</p>
        <h4>8.5.3  重写的返回类型</h4>
        <p>方法有它的返回类型，而重写的方法也有返回类型，并有一些相应的限制。方法被重写后，返回的类型为基本类型时，重写方法的返回要必须一样，否则会出现错误。</p>
        <h4>8.5.4  重写是基于继承的</h4>
        <p>重写和重载的产生是基于继承的，如果没有发生继承就不会产生重写和重载了。举个例子来说，自行车通过外力可以移动，而公路赛车通过外力也可以移动，公路赛车继承了自行车的特性。也可以说成，公路赛车是自行车的一个升级版本。相当于一个参照点吧，如图所示。</p>
        <img src="http://vbe.tutc.cc:8081/xml/image/201805171321.jpg" />
        <h4>8.5.5  静态方法是不能重写的</h4>
        <p>静态方法就是被修饰为了static类型的方法，如果在类里声明具有唯一性，不是通过类的实例化而存在的，而是通过类的建立而存在，可以理解为用关键字new创建对象了，就是把这个对象实例化了。</p>
        <hr />
        <p>对本节的内容进行如下总结。</p>
        <ul>
            <li>父类的静态方法可以被子类的静态方法覆盖</li>
            <li>父类的非静态方法不能被子类的静态方法覆盖</li>
            <li>父类的静态方法不能被子类的非静态方法覆盖</li>
            <li>覆盖是用于父类和子类之间</li>
            <li>重写是用在同一个类中，有相同的方法名，但参数不一样</li>
        </ul>
        <h4>8.5.6  三者之间的关系</h4>
        <p>重写的关键字是override，重载的关键字为overload，重写、重载、覆盖都是基于继承的关系。当继承的关系发生了，想用父类的方法就用super关键字来引用，如果想用新的方法了就重写下，来完成新的功能需要。</p>
        <p>对覆盖总结如下：</p>
        <ul>
            <li>覆盖的方法的参数列表必须要和被覆盖的方法的参数列表完全相同，才能达到覆盖的效果</li>
            <li>覆盖的方法的返回值必须和被覆盖的方法的返回值一致</li>
            <li>覆盖的方法所抛出的异常必须和被覆盖方法的所抛出的异常一致，或者是其子类</li>
            <li>被覆盖的方法不能为private，否则在其子类中只是新定义了一个方法，并没有对其进行覆盖</li>
        </ul>
        <p>对重载总结如下：</p>
        <ul>
            <li>使用重载时只能定义不同的参数列表</li>
            <li>不能通过重载的方法的返回类型、访问权限和抛出的异常来进行方法的重载</li>
        </ul>
        <p>对重写总结如下：</p>
        <ul>
            <li>重写的方法存在于父类中，也存在于子类中</li>
            <li>重写的方法在运行期采用多态的形式</li>
            <li>重写的方法不能比被重写的方法有更高的访问限制</li>
            <li>重写的方法不能比被重写的方法有更多的异常</li>
        </ul>
        <h4>8.5.7  重写toString</h4>
        <p>toString()方法是Java里Object类的方法，很多类都重写了该方法。该方法返回对象的状态信息。下面是这个方法的原型：</p>
        <pre class="brush:java">public String toString()</pre>
        <h4>8.5.8  重写equals</h4>
        <p>方法equals也是Object类的方法，很多类也进行了重写，一般重写equals方法是为了比较两个对象的内容是否相等。下面是这个方法的原型：</p>
        <pre class="brush:java">public boolean equals（Object obj）
{
    return （this == obj）;	//这里比较的是两个对象的引用
}</pre>
        <h3>8.6  final与继承的关系</h3>
        <p>final关键字有最终、不变的意思，可以修饰成员变量，也可以修饰方法和类，通过final关键字的修饰可以改变其特性。</p>
        <p>final关键字修饰类时，说明其类不能有子类，也就是说该类不能被继承，该类的成员变量在这里将不起作用。</p>
        <p>final关键字修饰方法时，说明该方法不能被重写，因为类都不能继承了，方法就更不能重写了。</p>
        <p>类里可以含有final关键字修饰的方法。</p>
        <p>final关键字修饰的成员变量的对象引用不能修改。</p>
        <p>final关键字修饰的类里的方法默认被修饰为final。</p>
        <h3>8.7  abstract与继承的关系</h3>
        <p>abstract关键字表示抽象的意思。所谓抽象，就好比在日常生活中人们设计的图纸，而这个图纸就好比是一个抽象的房子似的，需要把房子盖起来来实现这个图纸。在Java里抽象类里最少要含有一个抽象方法，让它的子类去实现这个抽象方法，抽象类里也可以定义一些方法。</p>
        <h3>8.8  什么是多态</h3>
        <p>这里来拿苹果和馒头来打个比方，苹果属于水果的一种，馒头属于面食的一种，而苹果和馒头都可以属于食物，一种物品有两种状态表现，这就是多态，如图所示。</p>
        <img src="http://vbe.tutc.cc:8081/xml/image/201805171331.jpg" />
        <p>
            对本节学习的内容总结如下：<br />
            static修饰的方法和final修饰的方法是在编译期绑定的；而其他的方法是在运行期绑定，动态地判断是什么类型。<br />
            多态是基于继承的，是类和接口相结合来实现的。
        </p>
        <h3>8.9  什么是枚举类</h3>
        <p>所谓枚举就好比日常生活中的星期一、星期二到星期天，是一组连续的数据。在Java里枚举类就是一组连续的基本类型的数值。下面举例如何创建枚举类型。</p>
        <pre class="brush:java">public enum Grade
{
    A, B, C, D, E, F 
}</pre>
        <h3>8.10  什么是反射机制</h3>
        <p>在日常生活中，通过放大镜可以看清楚物体的内部结构。在Java中，反射机制就是起到放大镜的效果，可以通过类名，加载这个类，显示出这个类的方法等信息。</p>
        <h3>8.11  什么是泛型</h3>
        <p>在日常生活中，橡皮泥通过外力可以改变其形状，其形状是不固定的。在Java中，通过泛型可以给开发带来方便，通过参数的指定，可以改变其类型。下面通过代码演示。</p>
        <pre class="brush:java">public class Fanxing
{
    private T t; //t是一个泛型变量
    
    public void add(T t) {
        this.t = t;
    }

    public T get() {
        return t;
    }
}</pre>
        <p>使用泛型给程序员的代码编写带来了好处，也带来的缺点，了解它的好处和缺点，能给程序编写带来很多好处和便利。对泛型的好处总结如下：</p>
        <ul>
            <li>使用泛型，正如上面代码所示，能使代码看起来灵活；容易管理，不容易产生错误。</li>
            <li>使用泛型能使代码量减少，能产生很多公共代码。</li>
            <li>使用泛型在代码编译的时候能进行类型的检查并自动转换，使代码的运行效率得到提高。</li>
            <li>使用泛型在编译进行自动转换的时候出现了错误，会进行错误提示。</li>
            <li>使用泛型的时候参数只能是类的类型，不能是简单类型。</li>
            <li>使用泛型的时候参数可以有多个。</li>
            <li>使用泛型的时候参数也能继承别的类型。</li>
        </ul>
        <h3>8.12  综合练习</h3>
        <span>1.四种权限修饰符的不同点有哪些？</span>
        <p class="exap">【提示】从基本定义中进行分析。public修饰符表明被它修饰的成员变量为公共类型，这样这个成员变量在任何包里都能访问，包括子类也能访问到。private表明被它修饰的成员变量为私有类型，表示除了本类外任何类都不能访问到这个成员变量，具有很好的保护性。如果不给成员变量添加任何修饰符，就表示这个成员变量被修饰为default类型，在同一个包里的类或子类是能够访问的，就相当于public类型，但是在不同包里的类或子类没有继承该成员变量，是访问不到的。protected表明被它修饰的成员变量为保护类型，在同一包里和public类型是一样的，也是能够访问到的，但是如果在不同包里的protected类型的成员变量就只能通过子类来访问，这个修饰符是区别于其他修饰符的。</p>
        <span>2.重写和重载的区别有哪些？</span>
        <p class="exap">【提示】重写是基于继承的，重写是重写父类中的方法，从而在子类中出现一个和该方法相同名称的方法。重载的方法名称相同，但方法的参数列表不相同。如：参数个数和参数类型等。重载的方法的返回值可以相同也可以不相同。</p>
        <h3>8.13  小结</h3>
        <p>通过本小节的学习，同学们可以了解继承的相关概念、用法和注意事项等。对修饰符所修饰的成员变量和方法要多多理解，对以后的编码有帮助。本章重点学习，方法和成员变量的重写、重载、覆盖这些概念。如果想了解更多的关于本章的内容，可以参考电子工业出版社出版的<b>《深入浅出JDK 6.0》</b>一书进行学习。</p>
    </div>
</body>
</html>
